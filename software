details should depend on high level policy, high level policy should never depend on details. 

the source code is the design.
the running program is the product not the src code.

In software it's far cheaper to build the product than design it, even fixing error after release. comparing to other engineering discipline.

"A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated. The overall structure of the system may never have been well defined. If it was, it may have eroded beyond recognition. Programmers with a shred of architectural sensibility shun these quagmires. Only those who are unconcerned about architecture, and, perhaps, are comfortable with the inertia of the day-to-day chore of patching the holes in these failing dikes, are content to work on such systems."

Rigidity: tendency of the system to be hard to change.
  - time to build & test is high.
Fragility: 
  - high coupling compnents. change in one place break the code in others. 
Imobility:  
  - when the system internals cannot be extracted and reused in other environment
Viscosity: 
  - when necessary operations like testing and building are difcult to perform and taking a long time.
Needless Compexity:
  - try to anticipate all future requirements and add additional and needless complexity. sol : keep ur code focus on current requirements while maintaing a comprehensive suite of test that reduce ur fear of changing the design later.
---
o.f(x) vs f(o, x) :  
  1-caller don't know which impl of f will be called. caller is decoupled from the method he is call. {OO is about passing messages; when u pass a message, u lose control on how that message is going to be interpreted; u only hope the reciver react properly. } invert key dependencies, protecting high level policy from low level details. OO design is about dependencies management.
--
SOLID is about managing relationship and operation between classes (5)

Component Cohesion Principles[describe forces that cause classes to be grouped into independently deployable compnents ]:
  - The Release-Reuse Equivalency principle
  - THe Common Closure Principle.
  - The Common Reuse Principle.

Compnent Coupling Principles[describe forces that govern dependencies between components]:
  - The Acyclic Dependencies Principle
  - The Stable Dependencies Principle
  - The Stable Abstractions Principle
  
---------
Waterfall downsides:
  - late feedback
  - lack of responsability
circle of code:
  idea -> requirements -> code -> ci -> deploy -> feedback.  repeat
----
TDD is a discipline , has a rules u must follow. not just writing test when u fell u want it.
Bob Martin's 3 Rules of TDD
  1- You are not allowed to write any production code unless it is to make a failing unit test pass.
  2- You are not allowed to write any more unit test than is sufficient to fail; and compilation failures are failures.
  3- You are not allowed to write any more production code than is sufficient to pass the one failing test.
---------
Function:
  func should do one thing, it should do it well and it should do it only.
  large func hide classes.
  
  Extract till you Drop! to make sure ur func make one thing.
  
  braces {} are opportunite to extract
  
  if we have long function with local vars used by different part in function. 
  we should convert it to a one or more classes, try to detect duplication logic and give each 
  on a good descriptive name.
---------
  characterization test: u write it when u have legacy code try to refactor it. to
    make sure u have  not broken anything.
  -------
  [about methods]command & query separation: command -> change the state of the system but return nothing; query -> return something but not change the state.
  
  - Don't make coding decisions based on what I think might perform better. 
    I must benchmark or profile to know if code is not fast enough. Then 
    and only then should I optimize for performance. This can't be done until
    I have something working.
    "Make it correct, make it clear, make it concise, make it fast. In that order." -
     Wes Dyer
--------------
Incremental OO software:
  ch 01:
    - Incremental development builds a system feature by feature, instead of building
      all the layers and components and integrating them at the end. Each feature is
      implemented as an end-to-end “slice” through all the relevant parts of the system.
      The system is always integrated and ready for deployment.
      
      Iterative development progressively reﬁnes the implementation of features in
      response to feedback until they are good enough.
    
    - test first -> detects errors while the context is fresh in our mind (implementation);
    - Never write new functionality without a failing test. 
    
    - We use the term integration tests to refer to the tests that check how some of
      our code works with code from outside the team that we can’t change. It might
      be a public framework, such as a persistence mapper, or a library from another
      team within our organization. The distinction is that integration tests make sure
      that any abstractions we build over third-party code work as we expect.
    - In most professional development, however, we’ll want integration tests
      to help tease out conﬁguration issues with the external packages, and to give
      quicker feedback than the (inevitably) slower acceptance tests.
    
    - external and internal quality: External quality
      is how well the system meets the needs of its customers and users (is it functional,
      reliable, available, responsive, etc.), and internal quality is how well it meets the
      needs of its developers and administrators (is it easy to understand, easy to change, etc.). 
      Internal quality is what lets us cope with continual and unanticipated change.
      The point of maintaining internal quality is to allow us to modify the system’s behavior safely and predictably, 
      because it minimizes the risk that a change will force major rework.
  ch 02:
    - When designing a system, it’s important to distinguish between values that
      model unchanging quantities or measurements, and objects that have an identity,
      might change state over time, and model computational processes.
      
      In practice, this means that we split our system into two “worlds”: values,
      which are treated functionally, and objects, which implement the stateful behavior
      of the system.
      
    - the mismatch between static classiﬁcation and dynamic communication means that we’re
      unlikely to come up with a tidy class hierarchy for the game objects that will 
      also suit the needs of the engine.
      
      At best, a class hierarchy represents one dimension of an application, providing
      a mechanism for sharing implementation details between objects; for example,
      we might have a base class to implement the common features of frame-based
      animation. At worst, we’ve seen too many codebases (including our own) that
      suffer complexity and duplication from using one mechanism to represent multiple
      concepts.
    
    - We try to think about objects in terms of roles, responsibilities, and collaborators.
      a role is a set of related responsibilities;
      and a responsibility is an obligation to perform a task or know information. A
      collaboration is an interaction of objects or roles (or both).
      
    - We try to be sparing with queries on objects (as opposed to values) because
      they can allow information to “leak” out of the object, making the system a little
      bit more rigid. At a minimum, we make a point of writing queries that describe
      the intention of the calling object, not just the implementation.
    - The important point is to make clear the intention of every test, 
      distinguishing between the tested functionality, the supporting infrastructure,
      and the object structure.
    
