Ultimate GO:

Code Reviews:
  - Integrity:
    - every allocation, read and write of memory being accurate, consistent and efficient. The type system is critical making sure we have this micro level of integrity.
    - every [data transformation] being accurate, consistent and efficient. Writing less code and error handling is critical to making sure we have this macro level of integrity.
  - Go not hide cost like c++
  - Correctence -> readability ->  Comprehensible Code -> hide complexity without losing readability
  - Latency: external [sys call, network]; - internal [garabe collection, synchronization, orchasteration]; - how we access memory.; - algorithm efficiency. [readability is important than efficiency in most situations]

when we assign var from literal struct to named struct if they have the same memory layout
go will make an implicit conversion and accept it.
but, when we assign 2 var from different nammed struct but with the same memory layout
we must make an explicit conversion to make go compile.
------------------------------------------------------------------------
Go Use 2 words structure for string:
    one word contains a pointer to the start of the string.
    another contains the length of it.
-----------------------------------------------------------------
For consistency 
    - when declaring a variable use [var x type] when you don't initalize it,
      and use := if you will initialize with the declaration. 
-----------------------------------------------------------------
==> go build -gcflags -m=2
    - it shows us the escape analysis of our code
      which value moved to the heap to be accessible
      from upper stack frame after the current stack frame
      removed.
==> write code for readability, don't hide the cost of ur code.
______________________________________________________________________
each goroutine created initially with 2kb stack size, and when the stack 
need to grows more than 2kb go allocate another stack with double size
and move all frame to the new one. because of that go doesn't allow 
sharing data in the stack between different goroutines so any shared data
moved to the heap memory 
[go compiler use escape analysis to figure out which data need to be sotred in the heap]
https://en.wikipedia.org/wiki/Escape_analysis
-------------------------------
Go struct:
  - compiler perform alignment
  - in named type compiler don't perform implicit conversion,
    in literal type(in case of compatibility) will do.
  -  
Constants:
  - other lang, constansts are read-only var.
    In go, there are not variable and only available at the compile time.
    constant [kind of [at least 256 bits], type of same as their type]
  - kind of implicitly converted when used in expression. literals are kind of constant
  - iota , constants initially start with zero and each time increment by 1.
Garabage collector [non-generational, non-compacting, concurrent, sweep]
  memory on the heap is not moving, once allocation happened in the heap it's fixed 
    for the lifetime of the allocation. 
    priorites:
     1- maximize throughputs during collection, 
     2- memory resource usage.
_______________________________________________________________________________-
What is actually involved in a context switch depends on the architectures, operating systems, and the number of resources shared (threads that belong to the same process share many resources compared to unrelated non-cooperating processes). For example, in the Linux kernel, context switching involves switching registers, stack pointer (it's typical stack-pointer register), program counter, flushing the translation lookaside buffer (TLB) and loading the page table of the next process to run (unless the old process shares the memory with the new)s
----------------------------------------------------------------------------------------------
https://en.wikipedia.org/wiki/Green_threads
-----------------------------------------------------------------------------------------
type declaration vs aliasing:
  declaration copy the fields of the object.
  aliasing copy the fields and the method sets
=====
TESTING
-- 
  - when u run test go take all *_test.go files, build an exectuable and exectue it. then delete it. -> u can see it ps aux | grep go
  ----
  - Naming Convention : file : *_test.go
    - in most normal cases u will see one test file for each src file. oneToOne Relationship.
    - few othe caveats:
      - `export_test.go` to access unexported variables in external tests.
      - `*_internal_test.go` for internal tests
      - `example_*_test.go` for examples in isolated files
        - others: 
          - name the desired value in `want` variable.
          - set result in `got`
          - u can name the args of the called func `arg`
  - Signal:
    - There are 2 basic ways to signal that a test failed:
      - Fail = fail, but keep running.
      - FailNow = fail now stop test.
    these methods called rarely, because most of the time we will combine it with logging:
    - Error = Log + Fail
    - Errorf = Logf + Fail
    - Fatal = Log + FailNow
    - Fatalf = Logf + FailNow
    
    - If not using subtests, Fatal will prevent other test in that func from running.
