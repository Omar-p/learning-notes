Security:
    - out of the box:
        - content negoatiation
        - login / logout page
        - user
        - protection aganist common attacks [csrf , cors ...
        - cache control
            - Cache-Control: no-cache, no-store, max-age=0, must-revalidate
            - add this header to respones from authenticated endpoint. we can disable it or add our owm. 
          - to prevent caching the content of secured content. when someone use back in the browser after 
              the user logged out the content will not be loaded because it's not cached.
          - in controller u can in endpoint that return non sensitive data, u can enable it when 
            returning a ResponseEntity .cacheControl(CacheControl.maxAge(30, TimeUnit.SECONDS))    
      - X-Content-Type-Option: nosniff
          . tell the browser not to guess the Content-Type because certain browsers ignore 
              the Content-Type header and try to guess it.      
          why? in certain situation u can upload a polyblack  file(image) and it can be a valid JS as well,
          then u can execute a cross-site scriptting attack by uploading an image.
      - X-Frame-Options: DENY    
          Disabling Framing -> prevent user from clicking on our site without being aware of it[Clickjacking].
          - done by overlaying a malicious site on the top of the target site, the malicious site can load the target
            site in the background and any action on the malicious site are taking place on the target site.
          --config-
          u can allow frame from the same origin -> #HttpSecurity.headers().frameOptions().sameOrigin()
          or for a specific domain  #HttpSecurity.headers().addHeaderWriter(new StaticHeadersWriter("X-FRAME-OPTIONS", "ALLOW_FROM domain.com"))
          
      - X-XSS-Protection: 1; mode=block
        Reflective XSS
        prevent browser from rendering a page if it suspects a Reflective XSS attack.
          Reflective XSS attack is when content is submitted or injected[malicious code] into ur web app and executed
            by the client browser against our app.
          


      - CSRF
      [only use the CSRF token for state changing ops such as POST, PUT, DELETE, PATCH]
          . this attack is taking advantages of that a browser will send any cookies associated with 
          a certain domain to that domain  .
              - we have session cookie for bank.com, when another website[attacker.com] send a req from
              ur browser to bank.com the browser will send the cookie [session associated with bank.com]
              with the request.
          . spring use [Synchronizer Token Pattern]     to protect against CSRF, spring send 
            a randomly generated token with cookies to the browser [browser has no knowledge about it because it an app specific]
            . so spring will expect from client to send the token with each state changing request or the request will be rejected
              by CsrfFilter
          . in thymleaf form <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />

          . if u using SPA, u can configure cserf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) to place token inside the cookie ,
            that way the jsClient can extract the token from the cookie and send it with the request. 
            the CsrfFilter will compare the token in the request against the one in the cookie.
            ## Browser restrict JS to only access the cookies for their domain.
          . if u use stateless basic or digest authentication u still need CSRF protection as the Browser
            will include the basic and digest Authorization header by default
    - CSP
      to access contentSecurityPolicy HttpSecurity.headers.contentSecurityPolicy("value")        
    - Https 
        - to make spring redirect any request for HTTP to HTTPS .requiresChannel()
            .requestMatchers(r -> [match requests in production for example. 
            because development with http is easier])  hsts headers will included by default, u can disable or configure it.
    - getPrinciple -> access to currently logged in user.
    - ..
    - FilterChainProxy -> composing other filters into a single filter.
        - entry point of all web based security.
    - spring scurity focus on application security
        - Authentication | Authorization | protection aganist common attack.
        - separation between authentication and authorization because of authentication is one time thing. 
            authorization spread through the entire application.
    
    - antMatchers vs mvcMatchers:
        - use antMatchers when u use spring security without spring [strut for example]
        - when u use spring use mvcMatchers /foo -> willmatch -> /foo.json /foo.php ..
        - keep order in ur mind most restrictive endpoints in the top.
        .access('spEl')
        .access("@beanName.predicateMethod(param1, param..)")
        .mvcMatchers("/users/{name}").access("#name == principal?.username") <- the user only can access his data only.
        - map (RequestMatcher, Collection<ConfigAttribute>) FilterInvocationSecurityMetadataSource --> 
            SecurityMetadataSource[default impl -> ExpressionBasedFilterInvocationSecurityMetadataSource]. 
        - AccessDecisionManager[route of all things access in spring security] 3 impl 
            [default: AffirmativeBased (1 yes -> access), ConsensusBased (majority yes -> access), UnanimousBased (all say yes)]
        - PasswordEncoderFactories.createDelegatingPasswordEncoder
            - new DelegatingPasswordEncoder(id, encoders[id -> endcoder])
            - when u want to migrate password to use another encoder , implement UserDetailsPasswordService and override 
            updatePassword and sprind will call it automatically.
        - WebExpressionVoter -> AccessDecisionVoter<FilterInvocation>
            FilterInvocation:
                - curr req, curr response, context[all configAttributes]
        - all these work after [AbstractSecurityInterceptor 2 impls (1: FilterSecurityInterceptor, 2: MethodSecurityInterceptor)]
        FilterWriter
        
        
        - Oauth is a framework that allows people to grant limited access to protected resources on the web. 
            the term access implies that oauth is about authorization, and this is true. however, 
                open Id connect [OIDC], formalizes a way to authenticate with oauth as well.
    - CommonOAuth2Provider -> contains info about well-known oauth2 providers.
    - ClientRegistrationRepository[InMemoryClientRegistrationRepository] ->
    - to initiate login flow OAuth2AuthorizationRequestRedirectFilter [if resolve the req then] redirect to OAuth endpoint itself.
    - to get the authorization code and exchange it for a valid user -> [OAuth2LoginAuthenticationFilter] -> 
        pass it to AuthenticationManager that delegat it to [OAuth2LoginAuthenticationProvider] that get 
            a response using the access token response client. 
    - from accessToken we need to get the user information for login using OAuth2UserService
        --> in this case we're just accessing a URI with the access token that was provided. And then create a user from that.
        - if u were using JWT, we could create it from id token itself.

Authentication#getName()
    - formLogin
    . return username field
    - openid
    . subject
    - Non-openid
    . vary depending on the custom impl[]FB/geithub claim -> id]
----
1-req from the client hit servlet container.
2-servlet container look up filter in web.xml
3-DelegatingFilterProxy[spring-security-filters registered with web container] delegate to FilterChainProxy which contains SecurityFilterChain
4-filter registered in web.xml with filter-mapping[filter-name, url-pattern].

securityFilterChainProxy loop over FilterChain to send req to matched filterChain.

5-FilterChain
. ChannelProccessingFilter
. SecurityContextPersistentFilter -> 
    manage securityContext[hold details of authenticated principal] 
    if there is no authenticated principal in securityContext repo[httpSessionRepo in web]
        it 'll add an empty securityContext to securityContextHolder[thread local].
. AuthenticationFilters   -> if authentication succeeded it will set Authentication
    in the securityContext.
. RememberMeAuthenticationFilter
. AnonymousAuthenticationFilter -> set AnonymousAuthenticationObject in securityContext.
. ExceptionTranslationFilter -> handle exceptions thrown by FilterSecurityInterceptor.
    may redirect client to an error page. or update headers.
    * contains authenticationEntryPoint#defaultEntryPoint#LoginUrlAuthenticationEntryPoint -> generate login page.
. FilterSecurityInterceptor -> check authorization against authenticationPrincipal.

6- when request hit AuthenticationFilters:
filter will extract credientals from req and create approperiate AuthenticationToken
    send it to authenticationManager which iterate over AuthenticationProvider to find which supports
    that token and authenticate it against that provider. provider use UserDetailsServic to 
    load data from where we store the identities.
        return authenticated authenticationPrincipal if the info is valid.
        and set the principal to the SecurityContext.
Header[WWW-Authenticate: Basic realm="Realm"] tell the browser basicAuth was required.       
-------
DelegatingFilterProxy  -delegate Regquest To -> FilterChainProxy --assign the req to the appropriate SecurityFilterChain
    securityFilterChain are simply collection of filter that perform security check on the req.
    .. we can define different securityfilterChain to different endpoint with different authentication method.
        ..the only passed requests reach to the ServletRequest.
    for oauth2 2filters to handle the OAUTH2 authorization code grant flow:
    OAutg2AuthorizationRequestRedirectFilter
    OAuth2LoginAuthenticationFilter
        --> /oauth2/authorization/<registrationID>  <-- will intercepted by OAutg2AuthorizationRequestRedirectFilter
        which will generate redirect uri for authorization server.
        - after user agree on consent screen, IDP redirect with auth_code and state_token to protect against CSRF to
        REDIRECT_URL/login/oauth2/code/<registrationID>/?code=&state=
        which delegated to OAuth2LoginAuthenticationFilter then delegate to AuthenticationManager to perform 
            actual authentication --authenticate<Authentication Provider>--> [OidcAuthorizationCodeAuthenticationProvider|
            OAuth2LoginAuthenticationProvider..] --> exchange auth_code with access_token.. 
