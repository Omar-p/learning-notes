  if we set properties file in the same path with the jar of our app, it 
  will override the properties file that is inside the jar.


----------------------------------------------------------------
Core:
  Aop:
    - based on simple predicate[all method in package, all method with specific return datatype..] we invoke some methods. Around | Before | After 
    - before ProceedingJoinPoint we can for example start transaction, check some condition, log the operation...
    - capture the return data of invocation.
    - After it we can close the transaction for example ...
    - u can do the same without AOP by extending the class. and adding the logic u want. but Aop do it in more convenient way.
    - useful when u want to execute methods on objects. [cross cutting concerns between objects]
  Servlet Filter:
    - implements javax.servlet.Filter
    -----------------------------------------------------------------------------

	        
  -------------------------------------------------------		
Data:
  Transaction:
    ts management ensure data consistency and integrity.
      - global ts: Multiple resources manage the transactions[managed by app server allowing for access to multiple resources(message queue, db..)]
      - local ts:  one resource manage the transaction[jdbc connection]
      
      -Programmatic: Developers writes custom code to manage transactions and set boundaries.
      -Declarative: separate transaction managemnt from business code.
      - LEVELS [DEFAULT(underlying DBMS), READ_UNCOMMITED, READ_COMMITED, REPEATABLE_READ, SERIALIZABLE]
  - when we add @Repository to any bean, spring automatically translate all JDBC exceptions to Spring Specific Exception    

-----
Integration:
  endpoints pass messages[header+payload] via channels:
    - Adapters(connect ur channel to some other system)
    - Filter(remove some messages from channels based on header, content, etc.)
    - Transformer (convert a message content or structure)
    - Enricher (add content to the message header or payload)
    - Service activator (invoke service operation based on the arrival of a message)
    - Gateway (connect your channels without SI coupling)
 Message Channels
  . 2 General classifications of message channels
    - Pollable Channel
    - Subscribable Channel
    
  - Pollable Channel:
    . May buffer its messages
      . Require a queue to hold the message
      . the queue has a designated capacity
    . Waits for the consumer to get the messages
      . consumers actively poll to recieve msgs.
    . Typically a Point-to-Point Channel
      . Only one reciever of a message in the channel,
    . Usually used for sending information or "document" message between endpoints      
  - Subscribable Channel
     Allows multiple subscribers (or consumers) to register for its messages.
       Messages are delivered to all registered subscribers on message arrival
       It has to manage a list or registry of subscribers.
    Doesn’t buffer its messages
    Usually used for “event” messages
      Notifying the subscribers that something happened and to take appropriate action.   
  -----
  Adapters
    An endpoint that connects a channel to an external system.
      . it "provide the bridge between integration framework and the external
         systems and service"
      . Providing separation of the messaging concerns from the transports and 
        protocols used
    Adapter are inbound or outbound 
      . Those that bring messages into the SI channels.
      . Those that get msg from SI channels to the outside app, db, etc.
    Built-in Adapter
      File, JMS, JDBC & JPA, FTP, FEED RSS, MAIL ADAPTER,..             
----------
TEST
 @DataJpaTest
   - by default, each test method runs in its own transaction, which is rolled back after 
     the method has executed. This way, the database state stays pristine between tests and 
     the tests stay independent of each other.      
  - @TestPropertySource(properties = {
        "spring.jpa.hibernate.ddl-auto=validate"
    })
-----------------------
Data:
  RowMapper: When each row of a ResultSet maps to a domain Object, 
   can be implemented as private inner class.

  RowCallbackHandler: When no value is being returned from callback 
    method for each row, e.g. writing row to a file, converting rows 
    to a XML, Filtering rows before adding to collection. Very efficient 
    as ResultSet to Object mapping is not done here.
 
  ResultSetExtractor: When multiple rows of ResultSet map to a single Object.
   Like when doing complex joins in a query one may need to have access to entire 
   ResultSet instead of single row of rs to build complex Object and you want to take 
   full control of ResultSet. Like Mapping the rows returned from the join of TABLE1 and TABLE2 
   to an fully-reconstituted TABLE aggregate.

  ParameterizedRowMapper is used to create complex objects
---------------
Boot:
  @SpringBootApplication annotated with:
    @SpringBootConfigurations <- specialization of Spring @Configuration
    @ComponentScan
    @EnableAutoConfiguration <- switch on spring boot intelligent 
        configuration based on classpath and configured properites.
   ---
   @ComponentScan
     search for components declared in the same package or any child of it.     
     
     @Compnent   
      specailized ones:
        @Configuration
        @Service
        @Repository
        @RestController
        @Controller
    
     - u don't have to use it in the app, we can declare all our
       components in a Configuration class using @Bean. if we don't
       like ComponentScan. we can use @Import in the configuration class
        to pull beans declaration from other classes or xml.
        
    ---
    spring boot use User configuration under @CompnentScan to add user beans then
     the @EnableAutoConfiguration add beans based on what defined in the classpath 
    @EnableAutoConfigurations   
      - get all classes defined in spring.factories, if there are conditional annotations
        on them then evaluate if all are true. spring will check the conditional annotations
        on the method of beans' definiation and register what are evaluated to true.
      - if our configurations depend on each other, we need to explicitly order them by 
        annotation (relatively is easily)   @AutoConfigureAfter(*.class) @AutoConfigureBefore()
         if u depend on one from other project u can specify string of the fully qualifiedName
           of that configuration

    @ConditionalOnMissingBean --> applied if there is no other bean definiation with
     the same type.
    
    class level @ConditionalOnClass([].class) configs applied if the class not in the classpath.
    
    
    spring-boot-configuration-processor
      - generates metadata about classes in your application that are 
        annotated with @ConfigurationProperties
      - looking for all classes annoted with ConfigurationProperties and provide 
       auto-completion for them in the properties file. 
       
   to register configurations to spring to load:
        src/main/resources/META-INF/spring.factories
         org.springframework.boot.autoconfigure.EnableAutoConfigurations=qulifiedClassName

   to get what match and what don't, run in --debug, or if u enable actuator:
     /autoconfig endpoint will give u the report for that.
-----
profiles: 

application-{profile name}.yml

@Profile({"!prod", "!qa"})
@Configuration
public class

Note that the spring.profiles.active property name contains the plural word pro-
files. This means you can specify more than one active profile.
spring:
  profiles:
    active:
     - prod
     - audit
     - ha    

@Profile("dev")


It involves placing profile-specific properties alongside nonprofiled properties in
application.yml, separated by three hyphens and the spring.profiles property to
name the profile.

properties fileName specified by properties [spring.config.name]

we can separate yaml properties file into section for different profiles:
  spring: config: activate: on-profile: [profile-name]
---
spring:
  profiles: prod
------------

  the @RestController annotation tells Spring that all handler methods in the 
  controller should have their return value written directly to the body of 
  the response, rather than being carried in the model to a view for rendering.
