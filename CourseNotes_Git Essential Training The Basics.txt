
 git system level configurations that will apply to every user of this computer by default.
  /etc/gitconfig
User level:
  ~/.gitconfig
Project level:
  my_project/.git/config 

  to set or modify this configuration in diff level
          git config --system %%% : system level.

------------------------------------------------------------------------
        git config --global %%% : user level.
------------------------------------------------------------------------
In Project directory:
git config 


        git help log == man git-log    


     Bullet points are usually asterisks or hyphens.
Can add "tracking numbers" from bugs or support requests. 

    commit message example:
[github-issue-num]  short description
blank line
long message 



           git log --since=yyyy-mm-dd     

           grep abbreviation for "globally search for regular expression. 


         git diff 
show us difference between files in the working directory and staging tree. 



           git diff --staged
show us the difference between the file in the staging tree and repository 

            --staged == --cached           




0:04:31            git diff --color-words 
show us word that changed. 


        git   diff sha1..sha1
compare 2 commits 
                
      when we renaming a file, all that minor changes that are in there get folded in, as well. 



git checkout  -- <file>
to discard changes in working directory.
-- to specify you want to discard file change not changing a branch. 


 git reset HEAD <file> 
to unstage them 


git commit --amend 
   make us be able to add changes to the last commit because no commits are depending on it's SHA-1, this is not
  possible for the previous ones. 


to retrieve a specific version of [file] from previous commit.
  git checkout commit-SHA -- [file]
it will bring in your stagging tree the file after changes in the desired commit. 



 git revert commit-SHA1         



 git [-i -f -n] clean
delete untracked files in the repository. 



ignore compiled code and [packages and compressed files]
ignore assets by users
ignore log files and database
ignore operating systems generated file. 


  How to make ignore pattern on user specific [globally] not repository specific ?
  git config --global core.excludesfile ~/.[gitignore_global] <-- any filename you chose. 


       how to ignore tracked file?
-- 
git rm --cached [file_name] 


git diff View difference between Stage and Working Directory
git diff --staged View difference between HEAD and Stage
git diff HEAD View difference between HEAD and Working Directory 

 GIT:
  is designed to be a file tracking system
  Tracks files
  Tracks the directories it takes to get to files
  Ignore directories with no files 

    git ls-tree HEAD
list all files and folders tracked in the HEAD commit. 

it's a convention when you need to track empty directory add .gitkeep file in it. 

---------------NEW AREA-----------------
git is a content addressable storage system.

blob commits stored in .git/objects/hash
stagging area only keep track of files not directory so we cannot store empty directory.

to print the file type that generate a hash
  git cat-file -t [hash]

to print the content
  git cat-file -p [hash] 
  
---
References - pointers to a commit:
  tags.
  branches.
  HEAD - a pointer to the current commit.
.git/HEAD
.git/refs/heads <- where branches live.

--------------
to rename branch
  git branch -m oldName newName
if u want to rename the HEAD branch.
  git branch -m newName

to delete branch
  git branch -d name 
force delete[has not merged workd].
  git branch -D name
u cannot delete HEAD branch
--
Git file managment:
  - untracked
    . Stay in directory
  - Staged 
    . Stay in staged state.
  - Committed
    . changes not visible when switch branch.
----
git add -p
  allows u to stage commits in hunks, interactively.
  it's useful if u've done too much work for one commit.

working area --add-> staging area --commit--> repo
working area <--checkout-- staging area
working area <--checkout branch|sha -- repo
----
stash
  save un-committed work.
  the stash is safe from destructive operations
git stash --include-untracked

name stash for easy reference:
  git stash save "refName"

git stash [list]
git stash [apply] stash@{}

git stash -p [select interactively what u want to include]
----
git diff [different between working area and staging area]
git diff --cached [different between staging area and committed]
git diff HEAD [different between working area and committed ]
--
each command ask 2Q:
  - how does this command move info across the 4 Areas[stash, working area, Index, Repository]?
  - how does this command change the Repository?
    . checkout [branch].
      . move state from that branch in repo to my working area and index. modify HEAD
    . reset
      . move to another commit that is belonging to the current branch
      . options;
        --mixed(default) copy state of the commit to the index.
        --hard copy state of the commit to the index and working area.
        --soft just move to the commit and don't touch wa or index
      . u made #commits and u realize u don't need them . then reset --hard to the last one u want.
      . ignore all changes in index and wa : git reset --hard HEAD
      . unstage: git reset HEAD files. -> make index == last commit
--
git rm --cached file
  remove new file from stagging area. [make them untracked]
git rm -f file
------HEAD FIRST GIT--------

why we need version control:
  - keep src files safe.
  - retain a history of changes.
  - treat and attribute credit (or blame!)
  - allow for seamless collaboration between multiple team members.
  
-------------------------------------