Schema:
  namespace to organize naming of the object.
  postgres create by default schema called public.
  [schema_name].[object_name]
  
  when u access a table without specifying a schema name, pg searches for that table 
  by using the [schema search path], which is a list of schemas to look in.
  . The first schema in the search path is called the current_schema. 
  . PostgreSQL will access the first matching table in the schema search path. 
    If there is no match, it will return an error, even the name exists in another
     schema in the database.
  
  $ SELECT current_schema;
  
  To view the current search path, you use the SHOW command in psql tool:
  $ SHOW search_path;
  
  change schema search path:
  $ SET search_path TO [schema_name];
  
  Users can only access objects in the schemas that they own.
  To allow users to access the objects in the schema that they do not own,
   you must grant the USAGE privilege of the schema to the users:
   $ GRANT USAGE ON SCHEMA schema_name 
     TO role_name;
  
  To allow users to create objects in the schema that they do not own,
   you need to grant them the CREATE privilege of the schema to the users:
  
   $  GRANT CREATE ON SCHEMA schema_name 
			TO user_name;
		
	$ [CREATE|ALTER|DROP] shema_name;

----
TABLESPACE: 
  A tablespace is a location on the disk where PostgreSQL stores 
  data files containing database objects e.g., indexes, and tables.

  pg uses a tablespace to map a logical name to a physical location on disk.
  
  PG comes with two default tablespaces:
    pg_default tablespace stores user data.
    pg_global tablespace stores global data.
  
  benefits:
    if a partition on which the cluster was initialized is out of
    space, you can create a new tablespace on a different partition
    and use it until you reconfigure the system.
    
     you can use statistics to optimize database performance. 
     For example, you can place the frequent access indexes or
     tables on devices that perform very fast e.g., solid-state
     devices, and put the tables containing archive data which is
     rarely used on slower devices.
  
  TO CREATE:
  $ CREATE TABLESPACE tablespace_name
    OWNER user_name
    LOCATION directory_path;  
  
  To create table, index, database in another tablespace other than 
  the default. specify it in the creation.
    $ CREATE DATABASE [table_name] 
      TABLESPACE ts_primary;
      
---
Sequence[relkind = 'S']:
  CREATE SEQUENCE [ IF NOT EXISTS ] sequence_name
    [ AS { SMALLINT | INT | BIGINT } ]
    [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] 
    [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ] 
    [ CACHE cache ]  ->  (determines how many sequence numbers are preallocated and stored in 
                         memory for faster access. One value can be generated at a time. 
                         default 1)
    [ [ NO ] CYCLE ]      
    [ OWNED BY { table_name.column_name | NONE } ]

  . when you use the SERIAL pseudo-type for a column of a table, behind the scenes, 
    PostgreSQL automatically creates a sequence associated with the column.
----
If a column alias contains one or more spaces, you need to surround it with double quotes like this:
  first_name || ' ' || last_name AS "full name",
------
ORDER BY sort_expresssion [ASC | DESC] [NULLS FIRST | NULLS LAST]
--
DISTINCT ON (cols,..) must match the prefix of cols in ORDER BY clause:
  . select first row in each group.
  cols in ON define the equality rows.
  Without ORDER BY, will picks any row in each group.
  SELECT DISTINCT ON (column1) column_alias,  column2 FROM table_name ORDER BY column1, column2; 
  *SELECT DISTINCT ON (bcolor) bcolor, fcolor FROM distinct_demo ORDER BY bcolor, fcolor; *
---
WHERE
  . The condition must evaluate to true, false, or unknown. It can be a boolean expression
     or a combination of boolean expressions using the AND and OR operators.
  . If you use column aliases in the SELECT clause, you cannot use them in the WHERE clause.
    -> because query evaluates as: FROM -> WHERE -> SELECT -> ORDER BY
---
LIMIT row_count OFFSET row_to_skip;
  . If row_count is zero, the query returns an empty set. In case row_count is NULL, 
    the query returns the same result set as it does not have the LIMIT clause.  
    
  . The statement first skips row_to_skip rows before returning row_count rows generated
    by the query. If row_to_skip is zero, the statement will work like it doesnâ€™t have 
    the OFFSET clause.  
--
FETCH is a SQL standard, LIMIT is not.
  . OFFSET start { ROW | ROWS }
    FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY
    
    - start is an integer that must be zero or positive. By default, it is zero.
      In case the start is greater than the number of rows in the result set, 
      no rows are returned;
  . OFFSET clause must come before the FETCH clause in SQL:2008, IN postgres 
    any order of them  will work.
  
  - FETCH FIRST and FETCH NEXT do exactly the same thing. The reason both exist 
    because of the preceding OFFSET clause. Using the word FIRST combined with 
    OFFSET can be confusing to a human reader.
  * SELECT film_id, title FROM film ORDER BY title OFFSET 5 ROWS FETCH FIRST 5 ROW ONLY; *   
---
  % many
  _ one
  PostgreSQL supports the ILIKE operator that works like the LIKE operator. 
  In addition, the ILIKE operator matches value case-insensitively.
  
   ~~	LIKE
   ~~*	ILIKE
  !~~	NOT LIKE
  !~~*	NOT ILIKE
-----
Inner Join:
  - The inner join examines each row in the first table (basket_a). It compares the value 
    in the fruit_a column with the value in the fruit_b column of each row in the second 
    table (basket_b). If these values are equal, the inner join creates a new row that contains 
    columns from both tables and adds this new row the result set.
  
  - When you join a table to itself (a.k.a self-join), you need to use table aliases. 
    This is because referencing the same table multiple times within a query results in an error. 
 
 Left Outer Join, Right Outer Join, Full Outer Join.
 ----
 Data Types:
   Big Serial is backed by a sequence.
    
--frontendmasters---

INSERT 0 0
  first zero it used to be an identifier for an objectId,
    which the don't use it anymore but it there because backward compatibility 

problem with the offset:
  - if one user paginate the rows and in the some time some user delete row from the same page,
    the first row in the next page will not be appeared to the first user when he go to the next page.
  -- better approach is to page paginate them over a key, and instead using offset use WHERE with LIMIT
     that also is has more performance than OFFSET with LIMIT